
Led_pattern.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000556  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  000005ca  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000002  00800060  00800060  000005ca  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000005ca  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000005fc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000e8  00000000  00000000  00000638  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001138  00000000  00000000  00000720  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000007d1  00000000  00000000  00001858  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000080f  00000000  00000000  00002029  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000017c  00000000  00000000  00002838  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000054a  00000000  00000000  000029b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000603  00000000  00000000  00002efe  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000a8  00000000  00000000  00003501  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   8:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  10:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  14:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  18:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  1c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  20:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  24:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  28:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  2c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  30:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  34:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  38:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  3c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  40:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  44:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  48:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  4c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  50:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_clear_bss>:
  60:	20 e0       	ldi	r18, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	01 c0       	rjmp	.+2      	; 0x6a <.do_clear_bss_start>

00000068 <.do_clear_bss_loop>:
  68:	1d 92       	st	X+, r1

0000006a <.do_clear_bss_start>:
  6a:	a2 36       	cpi	r26, 0x62	; 98
  6c:	b2 07       	cpc	r27, r18
  6e:	e1 f7       	brne	.-8      	; 0x68 <.do_clear_bss_loop>
  70:	0e 94 31 02 	call	0x462	; 0x462 <main>
  74:	0c 94 a9 02 	jmp	0x552	; 0x552 <_exit>

00000078 <__bad_interrupt>:
  78:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000007c <Button_init>:
/* RETURN    : void                                              */
/*****************************************************************/
void Button_init(uint8_t Button_port , uint8_t Button_pin)
{
	/** SET THE DIRECTION OF BUTTON AS INPUT **/
	DIO_SETPINDIR(Button_port , Button_pin , DIO_PIN_INPUT);
  7c:	40 e0       	ldi	r20, 0x00	; 0
  7e:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
  82:	08 95       	ret

00000084 <Is_pressed>:
/* FUNCTION TO CHECK THE BUTTON STATUS PRESSED OR NOT            */
/* ARGUMENTS : TAKES THE BUTTON PIN                              */
/* RETURN    : RETURNS BUTTON_t type                             */
/*****************************************************************/
button_t Is_pressed(uint8_t Button_port , uint8_t Button_pin , uint8_t * value)
{
  84:	0f 93       	push	r16
  86:	1f 93       	push	r17
  88:	cf 93       	push	r28
  8a:	df 93       	push	r29
  8c:	1f 92       	push	r1
  8e:	cd b7       	in	r28, 0x3d	; 61
  90:	de b7       	in	r29, 0x3e	; 62
  92:	8a 01       	movw	r16, r20
	button_t button_state = Button_Notpressed ; /* VARIABLE TO HOLD THE RETURN TYPE OF THE FUNCTION */
	
	PinRead_t pin_status = NOT_VALID_READ ;  /** VARIABLE TO HOLD THE STATE OF PIN READ **/
	
	uint8_t pvalue = 0 ;
  94:	19 82       	std	Y+1, r1	; 0x01
	
	pin_status = DIO_READPIN(Button_port , Button_pin , &pvalue); /** READ THE BUTTON PIN VALUE */
  96:	ae 01       	movw	r20, r28
  98:	4f 5f       	subi	r20, 0xFF	; 255
  9a:	5f 4f       	sbci	r21, 0xFF	; 255
  9c:	0e 94 5f 01 	call	0x2be	; 0x2be <DIO_READPIN>
	
	if (!pin_status) 
  a0:	81 11       	cpse	r24, r1
  a2:	05 c0       	rjmp	.+10     	; 0xae <Is_pressed+0x2a>
	{
		button_state = Button_pressed ; /** RETURN THE STATUS AS BUTTON IS PRESSED **/
		*value = pvalue ;
  a4:	89 81       	ldd	r24, Y+1	; 0x01
  a6:	f8 01       	movw	r30, r16
  a8:	80 83       	st	Z, r24
	
	pin_status = DIO_READPIN(Button_port , Button_pin , &pvalue); /** READ THE BUTTON PIN VALUE */
	
	if (!pin_status) 
	{
		button_state = Button_pressed ; /** RETURN THE STATUS AS BUTTON IS PRESSED **/
  aa:	81 e0       	ldi	r24, 0x01	; 1
  ac:	04 c0       	rjmp	.+8      	; 0xb6 <Is_pressed+0x32>
	}
	
	else
	{
		button_state = Button_Notpressed ; /** RETURN THE STATUS AS BUTTON IS PRESSED **/
		*value = pvalue ;
  ae:	89 81       	ldd	r24, Y+1	; 0x01
  b0:	f8 01       	movw	r30, r16
  b2:	80 83       	st	Z, r24
		*value = pvalue ;
	}
	
	else
	{
		button_state = Button_Notpressed ; /** RETURN THE STATUS AS BUTTON IS PRESSED **/
  b4:	80 e0       	ldi	r24, 0x00	; 0
		*value = pvalue ;
	}
	
	return button_state ; /** RETURN THE STATUS OF THE BUTTON **/
}
  b6:	0f 90       	pop	r0
  b8:	df 91       	pop	r29
  ba:	cf 91       	pop	r28
  bc:	1f 91       	pop	r17
  be:	0f 91       	pop	r16
  c0:	08 95       	ret

000000c2 <DIO_SETPINDIR>:
/******************************************************************/
PinDirection_t DIO_SETPINDIR(uint8_t portID , uint8_t pinID , uint8_t dir)
{
	PinDirection_t Local_dirstate = VALID_DIRECTION ; /** VARIABLE TO RETURN THE STATUS OF DIRECTION **/
	
	switch(dir) /** SWITCH CASE ON THE DIRECTION VALUE **/
  c2:	44 23       	and	r20, r20
  c4:	19 f0       	breq	.+6      	; 0xcc <DIO_SETPINDIR+0xa>
  c6:	41 30       	cpi	r20, 0x01	; 1
  c8:	e9 f1       	breq	.+122    	; 0x144 <DIO_SETPINDIR+0x82>
  ca:	74 c0       	rjmp	.+232    	; 0x1b4 <DIO_SETPINDIR+0xf2>
	{
		case DIO_PIN_INPUT:  /* INPUT CASE  */
		
		switch(portID) /** SWITCH CASE ON THE PORT ID */
  cc:	81 30       	cpi	r24, 0x01	; 1
  ce:	99 f0       	breq	.+38     	; 0xf6 <DIO_SETPINDIR+0x34>
  d0:	28 f0       	brcs	.+10     	; 0xdc <DIO_SETPINDIR+0x1a>
  d2:	82 30       	cpi	r24, 0x02	; 2
  d4:	e9 f0       	breq	.+58     	; 0x110 <DIO_SETPINDIR+0x4e>
  d6:	83 30       	cpi	r24, 0x03	; 3
  d8:	41 f1       	breq	.+80     	; 0x12a <DIO_SETPINDIR+0x68>
  da:	6e c0       	rjmp	.+220    	; 0x1b8 <DIO_SETPINDIR+0xf6>
		{
			case DIO_PORTA:
			clear_bit(DDRA , pinID);           /** CONFIGURE THIS PIN IN PORTA AS INPUT PIN **/
  dc:	2a b3       	in	r18, 0x1a	; 26
  de:	81 e0       	ldi	r24, 0x01	; 1
  e0:	90 e0       	ldi	r25, 0x00	; 0
  e2:	02 c0       	rjmp	.+4      	; 0xe8 <DIO_SETPINDIR+0x26>
  e4:	88 0f       	add	r24, r24
  e6:	99 1f       	adc	r25, r25
  e8:	6a 95       	dec	r22
  ea:	e2 f7       	brpl	.-8      	; 0xe4 <DIO_SETPINDIR+0x22>
  ec:	80 95       	com	r24
  ee:	82 23       	and	r24, r18
  f0:	8a bb       	out	0x1a, r24	; 26
			Local_dirstate = VALID_DIRECTION ; /** RETURN AS DIR NO ERRORS **/
  f2:	80 e0       	ldi	r24, 0x00	; 0
			break;
  f4:	08 95       	ret
			
			case DIO_PORTB:
			clear_bit(DDRB , pinID);           /** CONFIGURE THIS PIN IN PORTB AS INPUT PIN **/
  f6:	27 b3       	in	r18, 0x17	; 23
  f8:	81 e0       	ldi	r24, 0x01	; 1
  fa:	90 e0       	ldi	r25, 0x00	; 0
  fc:	02 c0       	rjmp	.+4      	; 0x102 <DIO_SETPINDIR+0x40>
  fe:	88 0f       	add	r24, r24
 100:	99 1f       	adc	r25, r25
 102:	6a 95       	dec	r22
 104:	e2 f7       	brpl	.-8      	; 0xfe <DIO_SETPINDIR+0x3c>
 106:	80 95       	com	r24
 108:	82 23       	and	r24, r18
 10a:	87 bb       	out	0x17, r24	; 23
			Local_dirstate = VALID_DIRECTION ; /** RETURN AS DIR NO ERRORS **/
 10c:	80 e0       	ldi	r24, 0x00	; 0
			break;
 10e:	08 95       	ret
			
			case DIO_PORTC:
			clear_bit(DDRC , pinID);           /** CONFIGURE THIS PIN IN PORTC AS INPUT PIN **/
 110:	24 b3       	in	r18, 0x14	; 20
 112:	81 e0       	ldi	r24, 0x01	; 1
 114:	90 e0       	ldi	r25, 0x00	; 0
 116:	02 c0       	rjmp	.+4      	; 0x11c <DIO_SETPINDIR+0x5a>
 118:	88 0f       	add	r24, r24
 11a:	99 1f       	adc	r25, r25
 11c:	6a 95       	dec	r22
 11e:	e2 f7       	brpl	.-8      	; 0x118 <DIO_SETPINDIR+0x56>
 120:	80 95       	com	r24
 122:	82 23       	and	r24, r18
 124:	84 bb       	out	0x14, r24	; 20
			Local_dirstate = VALID_DIRECTION ; /** RETURN AS DIR NO ERRORS **/
 126:	80 e0       	ldi	r24, 0x00	; 0
			break;
 128:	08 95       	ret
			
			case DIO_PORTD:
			clear_bit(DDRD , pinID);           /** CONFIGURE THIS PIN IN PORTD AS INPUT PIN **/
 12a:	21 b3       	in	r18, 0x11	; 17
 12c:	81 e0       	ldi	r24, 0x01	; 1
 12e:	90 e0       	ldi	r25, 0x00	; 0
 130:	02 c0       	rjmp	.+4      	; 0x136 <DIO_SETPINDIR+0x74>
 132:	88 0f       	add	r24, r24
 134:	99 1f       	adc	r25, r25
 136:	6a 95       	dec	r22
 138:	e2 f7       	brpl	.-8      	; 0x132 <DIO_SETPINDIR+0x70>
 13a:	80 95       	com	r24
 13c:	82 23       	and	r24, r18
 13e:	81 bb       	out	0x11, r24	; 17
			Local_dirstate = VALID_DIRECTION ; /** RETURN AS DIR NO ERRORS **/
 140:	80 e0       	ldi	r24, 0x00	; 0
			break;
 142:	08 95       	ret
		} 
		break;
		
		case DIO_PIN_OUTPUT:  /* OUTPUT CASE  */
		
		switch(portID) /** SWITCH CASE ON THE PORT ID */
 144:	81 30       	cpi	r24, 0x01	; 1
 146:	91 f0       	breq	.+36     	; 0x16c <DIO_SETPINDIR+0xaa>
 148:	28 f0       	brcs	.+10     	; 0x154 <DIO_SETPINDIR+0x92>
 14a:	82 30       	cpi	r24, 0x02	; 2
 14c:	d9 f0       	breq	.+54     	; 0x184 <DIO_SETPINDIR+0xc2>
 14e:	83 30       	cpi	r24, 0x03	; 3
 150:	29 f1       	breq	.+74     	; 0x19c <DIO_SETPINDIR+0xda>
 152:	34 c0       	rjmp	.+104    	; 0x1bc <DIO_SETPINDIR+0xfa>
		{
			case DIO_PORTA:
			set_bit(DDRA , pinID);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
 154:	2a b3       	in	r18, 0x1a	; 26
 156:	81 e0       	ldi	r24, 0x01	; 1
 158:	90 e0       	ldi	r25, 0x00	; 0
 15a:	02 c0       	rjmp	.+4      	; 0x160 <DIO_SETPINDIR+0x9e>
 15c:	88 0f       	add	r24, r24
 15e:	99 1f       	adc	r25, r25
 160:	6a 95       	dec	r22
 162:	e2 f7       	brpl	.-8      	; 0x15c <DIO_SETPINDIR+0x9a>
 164:	82 2b       	or	r24, r18
 166:	8a bb       	out	0x1a, r24	; 26
			Local_dirstate = VALID_DIRECTION ; /** RETURN AS DIR NO ERRORS **/
 168:	80 e0       	ldi	r24, 0x00	; 0
			break;
 16a:	08 95       	ret
			
			case DIO_PORTB:
			set_bit(DDRB , pinID);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
 16c:	27 b3       	in	r18, 0x17	; 23
 16e:	81 e0       	ldi	r24, 0x01	; 1
 170:	90 e0       	ldi	r25, 0x00	; 0
 172:	02 c0       	rjmp	.+4      	; 0x178 <DIO_SETPINDIR+0xb6>
 174:	88 0f       	add	r24, r24
 176:	99 1f       	adc	r25, r25
 178:	6a 95       	dec	r22
 17a:	e2 f7       	brpl	.-8      	; 0x174 <DIO_SETPINDIR+0xb2>
 17c:	82 2b       	or	r24, r18
 17e:	87 bb       	out	0x17, r24	; 23
			Local_dirstate = VALID_DIRECTION ; /** RETURN AS DIR NO ERRORS **/
 180:	80 e0       	ldi	r24, 0x00	; 0
			break;
 182:	08 95       	ret
			
			case DIO_PORTC:
			set_bit(DDRC , pinID);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
 184:	24 b3       	in	r18, 0x14	; 20
 186:	81 e0       	ldi	r24, 0x01	; 1
 188:	90 e0       	ldi	r25, 0x00	; 0
 18a:	02 c0       	rjmp	.+4      	; 0x190 <DIO_SETPINDIR+0xce>
 18c:	88 0f       	add	r24, r24
 18e:	99 1f       	adc	r25, r25
 190:	6a 95       	dec	r22
 192:	e2 f7       	brpl	.-8      	; 0x18c <DIO_SETPINDIR+0xca>
 194:	82 2b       	or	r24, r18
 196:	84 bb       	out	0x14, r24	; 20
			Local_dirstate = VALID_DIRECTION ; /** RETURN AS DIR NO ERRORS **/
 198:	80 e0       	ldi	r24, 0x00	; 0
			break;
 19a:	08 95       	ret
			
			case DIO_PORTD:
			set_bit(DDRD , pinID);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
 19c:	21 b3       	in	r18, 0x11	; 17
 19e:	81 e0       	ldi	r24, 0x01	; 1
 1a0:	90 e0       	ldi	r25, 0x00	; 0
 1a2:	02 c0       	rjmp	.+4      	; 0x1a8 <DIO_SETPINDIR+0xe6>
 1a4:	88 0f       	add	r24, r24
 1a6:	99 1f       	adc	r25, r25
 1a8:	6a 95       	dec	r22
 1aa:	e2 f7       	brpl	.-8      	; 0x1a4 <DIO_SETPINDIR+0xe2>
 1ac:	82 2b       	or	r24, r18
 1ae:	81 bb       	out	0x11, r24	; 17
			Local_dirstate = VALID_DIRECTION ; /** RETURN AS DIR NO ERRORS **/
 1b0:	80 e0       	ldi	r24, 0x00	; 0
			break;
 1b2:	08 95       	ret
		} 
		break;
		 
		 
		default:  /** DIRECTION ISN'T INPUT OR OUTPUT */
		Local_dirstate = NOT_VALID_DIRECTION ; /** RETURN AS DIR NOT VALID ERRORS **/
 1b4:	81 e0       	ldi	r24, 0x01	; 1
 1b6:	08 95       	ret
			clear_bit(DDRD , pinID);           /** CONFIGURE THIS PIN IN PORTD AS INPUT PIN **/
			Local_dirstate = VALID_DIRECTION ; /** RETURN AS DIR NO ERRORS **/
			break;
			
			default: /** DO NOTHING **/
			Local_dirstate = NOT_VALID_DIRECTION ; /** RETURN AS DIR NOT VALID ERRORS **/
 1b8:	81 e0       	ldi	r24, 0x01	; 1
 1ba:	08 95       	ret
			set_bit(DDRD , pinID);             /** CONFIGURE THIS PIN IN PORTA AS OUTPUT PIN **/
			Local_dirstate = VALID_DIRECTION ; /** RETURN AS DIR NO ERRORS **/
			break;
			
			default:  /** DO NOTHING **/
			Local_dirstate = NOT_VALID_DIRECTION ; /** RETURN AS DIR NOT VALID ERRORS **/
 1bc:	81 e0       	ldi	r24, 0x01	; 1
		Local_dirstate = NOT_VALID_DIRECTION ; /** RETURN AS DIR NOT VALID ERRORS **/
		break ; 
	} 
	
	return Local_dirstate ; /** RETURN THE STATE OF FUNCTION **/
}
 1be:	08 95       	ret

000001c0 <DIO_SETPINVAL>:
PinValue_t DIO_SETPINVAL(uint8_t portID , uint8_t pinID , uint8_t val)
{
	
	PinValue_t Local_valstate = VALID_VALUE ; /** VARIABLE TO RETURN THE STATUS OF VALUE **/ 
	
	switch(val)
 1c0:	44 23       	and	r20, r20
 1c2:	19 f0       	breq	.+6      	; 0x1ca <DIO_SETPINVAL+0xa>
 1c4:	41 30       	cpi	r20, 0x01	; 1
 1c6:	e9 f1       	breq	.+122    	; 0x242 <DIO_SETPINVAL+0x82>
 1c8:	74 c0       	rjmp	.+232    	; 0x2b2 <DIO_SETPINVAL+0xf2>
	{
		case DIO_PIN_LOW:  /** IN CASE PIN VALUE IS LOW */
		
		switch(portID)  /** SWITCH CASE ON THE PORT ID */ 
 1ca:	81 30       	cpi	r24, 0x01	; 1
 1cc:	99 f0       	breq	.+38     	; 0x1f4 <DIO_SETPINVAL+0x34>
 1ce:	28 f0       	brcs	.+10     	; 0x1da <DIO_SETPINVAL+0x1a>
 1d0:	82 30       	cpi	r24, 0x02	; 2
 1d2:	e9 f0       	breq	.+58     	; 0x20e <DIO_SETPINVAL+0x4e>
 1d4:	83 30       	cpi	r24, 0x03	; 3
 1d6:	41 f1       	breq	.+80     	; 0x228 <DIO_SETPINVAL+0x68>
 1d8:	6e c0       	rjmp	.+220    	; 0x2b6 <DIO_SETPINVAL+0xf6>
		{
			case DIO_PORTA:
			clear_bit(PORTA , pinID);       /** SET THIS PIN AS LOW **/
 1da:	2b b3       	in	r18, 0x1b	; 27
 1dc:	81 e0       	ldi	r24, 0x01	; 1
 1de:	90 e0       	ldi	r25, 0x00	; 0
 1e0:	02 c0       	rjmp	.+4      	; 0x1e6 <DIO_SETPINVAL+0x26>
 1e2:	88 0f       	add	r24, r24
 1e4:	99 1f       	adc	r25, r25
 1e6:	6a 95       	dec	r22
 1e8:	e2 f7       	brpl	.-8      	; 0x1e2 <DIO_SETPINVAL+0x22>
 1ea:	80 95       	com	r24
 1ec:	82 23       	and	r24, r18
 1ee:	8b bb       	out	0x1b, r24	; 27
			Local_valstate = VALID_VALUE ;  /** RETURN VALUE AS VALID **/
 1f0:	80 e0       	ldi	r24, 0x00	; 0
			break;
 1f2:	08 95       	ret
			
			case DIO_PORTB:
			clear_bit(PORTB , pinID);       /** SET THIS PIN AS LOW **/
 1f4:	28 b3       	in	r18, 0x18	; 24
 1f6:	81 e0       	ldi	r24, 0x01	; 1
 1f8:	90 e0       	ldi	r25, 0x00	; 0
 1fa:	02 c0       	rjmp	.+4      	; 0x200 <DIO_SETPINVAL+0x40>
 1fc:	88 0f       	add	r24, r24
 1fe:	99 1f       	adc	r25, r25
 200:	6a 95       	dec	r22
 202:	e2 f7       	brpl	.-8      	; 0x1fc <DIO_SETPINVAL+0x3c>
 204:	80 95       	com	r24
 206:	82 23       	and	r24, r18
 208:	88 bb       	out	0x18, r24	; 24
			Local_valstate = VALID_VALUE ;  /** RETURN VALUE AS VALID **/
 20a:	80 e0       	ldi	r24, 0x00	; 0
			break;
 20c:	08 95       	ret
			
			case DIO_PORTC:
			clear_bit(PORTC , pinID);       /** SET THIS PIN AS LOW **/
 20e:	25 b3       	in	r18, 0x15	; 21
 210:	81 e0       	ldi	r24, 0x01	; 1
 212:	90 e0       	ldi	r25, 0x00	; 0
 214:	02 c0       	rjmp	.+4      	; 0x21a <DIO_SETPINVAL+0x5a>
 216:	88 0f       	add	r24, r24
 218:	99 1f       	adc	r25, r25
 21a:	6a 95       	dec	r22
 21c:	e2 f7       	brpl	.-8      	; 0x216 <DIO_SETPINVAL+0x56>
 21e:	80 95       	com	r24
 220:	82 23       	and	r24, r18
 222:	85 bb       	out	0x15, r24	; 21
			Local_valstate = VALID_VALUE ;  /** RETURN VALUE AS VALID **/
 224:	80 e0       	ldi	r24, 0x00	; 0
			break;
 226:	08 95       	ret
			
			case DIO_PORTD:
			clear_bit(PORTD , pinID);       /** SET THIS PIN AS LOW **/
 228:	22 b3       	in	r18, 0x12	; 18
 22a:	81 e0       	ldi	r24, 0x01	; 1
 22c:	90 e0       	ldi	r25, 0x00	; 0
 22e:	02 c0       	rjmp	.+4      	; 0x234 <DIO_SETPINVAL+0x74>
 230:	88 0f       	add	r24, r24
 232:	99 1f       	adc	r25, r25
 234:	6a 95       	dec	r22
 236:	e2 f7       	brpl	.-8      	; 0x230 <DIO_SETPINVAL+0x70>
 238:	80 95       	com	r24
 23a:	82 23       	and	r24, r18
 23c:	82 bb       	out	0x12, r24	; 18
			Local_valstate = VALID_VALUE ;  /** RETURN VALUE AS VALID **/
 23e:	80 e0       	ldi	r24, 0x00	; 0
			break;
 240:	08 95       	ret
		} 
		break;
		
		case DIO_PIN_HIGH:
		
		switch(portID)
 242:	81 30       	cpi	r24, 0x01	; 1
 244:	91 f0       	breq	.+36     	; 0x26a <DIO_SETPINVAL+0xaa>
 246:	28 f0       	brcs	.+10     	; 0x252 <DIO_SETPINVAL+0x92>
 248:	82 30       	cpi	r24, 0x02	; 2
 24a:	d9 f0       	breq	.+54     	; 0x282 <DIO_SETPINVAL+0xc2>
 24c:	83 30       	cpi	r24, 0x03	; 3
 24e:	29 f1       	breq	.+74     	; 0x29a <DIO_SETPINVAL+0xda>
 250:	34 c0       	rjmp	.+104    	; 0x2ba <DIO_SETPINVAL+0xfa>
		{
			case DIO_PORTA:
			set_bit(PORTA , pinID);         /** SET THIS PIN AS HIGH  **/
 252:	2b b3       	in	r18, 0x1b	; 27
 254:	81 e0       	ldi	r24, 0x01	; 1
 256:	90 e0       	ldi	r25, 0x00	; 0
 258:	02 c0       	rjmp	.+4      	; 0x25e <DIO_SETPINVAL+0x9e>
 25a:	88 0f       	add	r24, r24
 25c:	99 1f       	adc	r25, r25
 25e:	6a 95       	dec	r22
 260:	e2 f7       	brpl	.-8      	; 0x25a <DIO_SETPINVAL+0x9a>
 262:	82 2b       	or	r24, r18
 264:	8b bb       	out	0x1b, r24	; 27
			Local_valstate = VALID_VALUE ;  /** RETURN VALUE AS VALID **/
 266:	80 e0       	ldi	r24, 0x00	; 0
			break;
 268:	08 95       	ret
			
			case DIO_PORTB:
			set_bit(PORTB , pinID);         /** SET THIS PIN AS HIGH  **/
 26a:	28 b3       	in	r18, 0x18	; 24
 26c:	81 e0       	ldi	r24, 0x01	; 1
 26e:	90 e0       	ldi	r25, 0x00	; 0
 270:	02 c0       	rjmp	.+4      	; 0x276 <DIO_SETPINVAL+0xb6>
 272:	88 0f       	add	r24, r24
 274:	99 1f       	adc	r25, r25
 276:	6a 95       	dec	r22
 278:	e2 f7       	brpl	.-8      	; 0x272 <DIO_SETPINVAL+0xb2>
 27a:	82 2b       	or	r24, r18
 27c:	88 bb       	out	0x18, r24	; 24
			Local_valstate = VALID_VALUE ;  /** RETURN VALUE AS VALID **/
 27e:	80 e0       	ldi	r24, 0x00	; 0
			break;
 280:	08 95       	ret
			
			case DIO_PORTC:
			set_bit(PORTC , pinID);         /** SET THIS PIN AS HIGH  **/
 282:	25 b3       	in	r18, 0x15	; 21
 284:	81 e0       	ldi	r24, 0x01	; 1
 286:	90 e0       	ldi	r25, 0x00	; 0
 288:	02 c0       	rjmp	.+4      	; 0x28e <DIO_SETPINVAL+0xce>
 28a:	88 0f       	add	r24, r24
 28c:	99 1f       	adc	r25, r25
 28e:	6a 95       	dec	r22
 290:	e2 f7       	brpl	.-8      	; 0x28a <DIO_SETPINVAL+0xca>
 292:	82 2b       	or	r24, r18
 294:	85 bb       	out	0x15, r24	; 21
			Local_valstate = VALID_VALUE ;  /** RETURN VALUE AS VALID **/
 296:	80 e0       	ldi	r24, 0x00	; 0
			break;
 298:	08 95       	ret
			
			case DIO_PORTD:
			set_bit(PORTD , pinID);         /** SET THIS PIN AS HIGH  **/
 29a:	22 b3       	in	r18, 0x12	; 18
 29c:	81 e0       	ldi	r24, 0x01	; 1
 29e:	90 e0       	ldi	r25, 0x00	; 0
 2a0:	02 c0       	rjmp	.+4      	; 0x2a6 <DIO_SETPINVAL+0xe6>
 2a2:	88 0f       	add	r24, r24
 2a4:	99 1f       	adc	r25, r25
 2a6:	6a 95       	dec	r22
 2a8:	e2 f7       	brpl	.-8      	; 0x2a2 <DIO_SETPINVAL+0xe2>
 2aa:	82 2b       	or	r24, r18
 2ac:	82 bb       	out	0x12, r24	; 18
			Local_valstate = VALID_VALUE ;  /** RETURN VALUE AS VALID **/
 2ae:	80 e0       	ldi	r24, 0x00	; 0
			break;
 2b0:	08 95       	ret
			break;
		} 
		break;
		
		default :
		Local_valstate = NOT_VALID_VALUE ;  /** RETURN VALUE AS NOT VALID **/
 2b2:	81 e0       	ldi	r24, 0x01	; 1
 2b4:	08 95       	ret
			clear_bit(PORTD , pinID);       /** SET THIS PIN AS LOW **/
			Local_valstate = VALID_VALUE ;  /** RETURN VALUE AS VALID **/
			break;
			
			default:
			Local_valstate = NOT_VALID_VALUE ;  /** RETURN VALUE AS NOT VALID **/
 2b6:	81 e0       	ldi	r24, 0x01	; 1
 2b8:	08 95       	ret
			set_bit(PORTD , pinID);         /** SET THIS PIN AS HIGH  **/
			Local_valstate = VALID_VALUE ;  /** RETURN VALUE AS VALID **/
			break;
			
			default:
			Local_valstate = NOT_VALID_VALUE ;  /** RETURN VALUE AS NOT VALID **/
 2ba:	81 e0       	ldi	r24, 0x01	; 1
		Local_valstate = NOT_VALID_VALUE ;  /** RETURN VALUE AS NOT VALID **/
		break ;
	} 
	
	return Local_valstate ; /** RETURN THE FINAL STATE OF THE FUNCTION */
}
 2bc:	08 95       	ret

000002be <DIO_READPIN>:
/******************************************************************/
PinRead_t DIO_READPIN(uint8_t portID , uint8_t pinID , uint8_t* val)
{
	PinRead_t Local_Pinstate = NOT_VALID_READ ;  /** VARIABLE TO HOLD THE FUNCTION ERROR STATE */
	
	switch(portID)  /** SWITCH CASE ON PORT ID **/
 2be:	81 30       	cpi	r24, 0x01	; 1
 2c0:	99 f0       	breq	.+38     	; 0x2e8 <DIO_READPIN+0x2a>
 2c2:	28 f0       	brcs	.+10     	; 0x2ce <DIO_READPIN+0x10>
 2c4:	82 30       	cpi	r24, 0x02	; 2
 2c6:	e9 f0       	breq	.+58     	; 0x302 <DIO_READPIN+0x44>
 2c8:	83 30       	cpi	r24, 0x03	; 3
 2ca:	41 f1       	breq	.+80     	; 0x31c <DIO_READPIN+0x5e>
 2cc:	34 c0       	rjmp	.+104    	; 0x336 <DIO_READPIN+0x78>
	{
		case DIO_PORTA:               /** PORTA  **/
		*val = get_bit(PINA , pinID); /** GET THE VALUE OF THE BIT **/
 2ce:	89 b3       	in	r24, 0x19	; 25
 2d0:	90 e0       	ldi	r25, 0x00	; 0
 2d2:	02 c0       	rjmp	.+4      	; 0x2d8 <DIO_READPIN+0x1a>
 2d4:	95 95       	asr	r25
 2d6:	87 95       	ror	r24
 2d8:	6a 95       	dec	r22
 2da:	e2 f7       	brpl	.-8      	; 0x2d4 <DIO_READPIN+0x16>
 2dc:	81 70       	andi	r24, 0x01	; 1
 2de:	89 bb       	out	0x19, r24	; 25
 2e0:	fa 01       	movw	r30, r20
 2e2:	80 83       	st	Z, r24
		Local_Pinstate = VALID_READ ;  /** READ IS VALID  **/
 2e4:	80 e0       	ldi	r24, 0x00	; 0
		break;
 2e6:	08 95       	ret
		
		case DIO_PORTB:               /** PORTB  **/
		*val = get_bit(PINB , pinID); /** GET THE VALUE OF THE BIT **/
 2e8:	86 b3       	in	r24, 0x16	; 22
 2ea:	90 e0       	ldi	r25, 0x00	; 0
 2ec:	02 c0       	rjmp	.+4      	; 0x2f2 <DIO_READPIN+0x34>
 2ee:	95 95       	asr	r25
 2f0:	87 95       	ror	r24
 2f2:	6a 95       	dec	r22
 2f4:	e2 f7       	brpl	.-8      	; 0x2ee <DIO_READPIN+0x30>
 2f6:	81 70       	andi	r24, 0x01	; 1
 2f8:	86 bb       	out	0x16, r24	; 22
 2fa:	fa 01       	movw	r30, r20
 2fc:	80 83       	st	Z, r24
		Local_Pinstate = VALID_READ ;  /** READ IS VALID  **/
 2fe:	80 e0       	ldi	r24, 0x00	; 0
		break;
 300:	08 95       	ret
		
		case DIO_PORTC:               /** PORTC  **/
		*val = get_bit(PINC , pinID); /** GET THE VALUE OF THE BIT **/
 302:	83 b3       	in	r24, 0x13	; 19
 304:	90 e0       	ldi	r25, 0x00	; 0
 306:	02 c0       	rjmp	.+4      	; 0x30c <DIO_READPIN+0x4e>
 308:	95 95       	asr	r25
 30a:	87 95       	ror	r24
 30c:	6a 95       	dec	r22
 30e:	e2 f7       	brpl	.-8      	; 0x308 <DIO_READPIN+0x4a>
 310:	81 70       	andi	r24, 0x01	; 1
 312:	83 bb       	out	0x13, r24	; 19
 314:	fa 01       	movw	r30, r20
 316:	80 83       	st	Z, r24
		Local_Pinstate = VALID_READ ;  /** READ IS VALID  **/
 318:	80 e0       	ldi	r24, 0x00	; 0
		break;
 31a:	08 95       	ret
		
		case DIO_PORTD:               /** PORTD  **/
		*val = get_bit(PIND , pinID); /** GET THE VALUE OF THE BIT **/
 31c:	80 b3       	in	r24, 0x10	; 16
 31e:	90 e0       	ldi	r25, 0x00	; 0
 320:	02 c0       	rjmp	.+4      	; 0x326 <DIO_READPIN+0x68>
 322:	95 95       	asr	r25
 324:	87 95       	ror	r24
 326:	6a 95       	dec	r22
 328:	e2 f7       	brpl	.-8      	; 0x322 <DIO_READPIN+0x64>
 32a:	81 70       	andi	r24, 0x01	; 1
 32c:	80 bb       	out	0x10, r24	; 16
 32e:	fa 01       	movw	r30, r20
 330:	80 83       	st	Z, r24
		Local_Pinstate = VALID_READ ;  /** READ IS VALID  **/
 332:	80 e0       	ldi	r24, 0x00	; 0
		break;
 334:	08 95       	ret
		
		default:
		Local_Pinstate = NOT_VALID_READ ;  /** READ IS NOT VALID  **/
 336:	81 e0       	ldi	r24, 0x01	; 1
		break;
	} 
	
	return Local_Pinstate ; /** RETURN THE FINAL STATE OF THE FUNCTION **/	
 338:	08 95       	ret

0000033a <LED_INIT>:
/** RETURNS : VOID                                **/
/***************************************************/
void LED_INIT(uint8_t led_port , uint8_t ledpin)
{
	
	DIO_SETPINDIR(led_port , ledpin , DIO_PIN_OUTPUT); /** SET THE LED PIN AS OUTPUT **/
 33a:	41 e0       	ldi	r20, 0x01	; 1
 33c:	0e 94 61 00 	call	0xc2	; 0xc2 <DIO_SETPINDIR>
 340:	08 95       	ret

00000342 <LED_ON>:
/** RETURNS : VOID                                **/
/***************************************************/
void LED_ON(uint8_t led_port , uint8_t ledpin)
{
	
	DIO_SETPINVAL(led_port , ledpin , DIO_PIN_HIGH); /** SET THE OUTPUT PIN AS HIGH **/
 342:	41 e0       	ldi	r20, 0x01	; 1
 344:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <DIO_SETPINVAL>
 348:	08 95       	ret

0000034a <LED_OFF>:
/** RETURNS : VOID                                **/
/***************************************************/
void LED_OFF(uint8_t led_port , uint8_t ledpin)
{
	
	DIO_SETPINVAL(led_port , ledpin , DIO_PIN_LOW); /** SET THE OUTPUT PIN AS LOW **/
 34a:	40 e0       	ldi	r20, 0x00	; 0
 34c:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <DIO_SETPINVAL>
 350:	08 95       	ret

00000352 <LED_pattern1>:

/** PATTERNS TO BE DISPLAYED */
void LED_pattern1(void)
{
	/** LED1 ON **/
	LED_ON(LED1_PORT , LED1_PIN);
 352:	62 e0       	ldi	r22, 0x02	; 2
 354:	82 e0       	ldi	r24, 0x02	; 2
 356:	0e 94 a1 01 	call	0x342	; 0x342 <LED_ON>
	LED_OFF(LED2_PORT , LED2_PIN);
 35a:	67 e0       	ldi	r22, 0x07	; 7
 35c:	82 e0       	ldi	r24, 0x02	; 2
 35e:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
	LED_OFF(LED3_PORT , LED3_PIN);
 362:	63 e0       	ldi	r22, 0x03	; 3
 364:	83 e0       	ldi	r24, 0x03	; 3
 366:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
	LED_OFF(LED4_PORT , LED4_PIN);
 36a:	64 e0       	ldi	r22, 0x04	; 4
 36c:	83 e0       	ldi	r24, 0x03	; 3
 36e:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
 372:	08 95       	ret

00000374 <LED_pattern2>:
}

void LED_pattern2(void)
{
	/** LED1 AND LED2 ARE ON **/
	LED_ON(LED1_PORT , LED1_PIN);
 374:	62 e0       	ldi	r22, 0x02	; 2
 376:	82 e0       	ldi	r24, 0x02	; 2
 378:	0e 94 a1 01 	call	0x342	; 0x342 <LED_ON>
	LED_ON(LED2_PORT , LED2_PIN);
 37c:	67 e0       	ldi	r22, 0x07	; 7
 37e:	82 e0       	ldi	r24, 0x02	; 2
 380:	0e 94 a1 01 	call	0x342	; 0x342 <LED_ON>
	LED_OFF(LED3_PORT , LED3_PIN);
 384:	63 e0       	ldi	r22, 0x03	; 3
 386:	83 e0       	ldi	r24, 0x03	; 3
 388:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
	LED_OFF(LED4_PORT , LED4_PIN);
 38c:	64 e0       	ldi	r22, 0x04	; 4
 38e:	83 e0       	ldi	r24, 0x03	; 3
 390:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
 394:	08 95       	ret

00000396 <LED_pattern3>:
}

void LED_pattern3(void)
{
	/** LED1 , LED2 AND LED3 ARE ON **/
	LED_ON(LED1_PORT , LED1_PIN);
 396:	62 e0       	ldi	r22, 0x02	; 2
 398:	82 e0       	ldi	r24, 0x02	; 2
 39a:	0e 94 a1 01 	call	0x342	; 0x342 <LED_ON>
	LED_ON(LED2_PORT , LED2_PIN);
 39e:	67 e0       	ldi	r22, 0x07	; 7
 3a0:	82 e0       	ldi	r24, 0x02	; 2
 3a2:	0e 94 a1 01 	call	0x342	; 0x342 <LED_ON>
	LED_ON(LED3_PORT , LED3_PIN);
 3a6:	63 e0       	ldi	r22, 0x03	; 3
 3a8:	83 e0       	ldi	r24, 0x03	; 3
 3aa:	0e 94 a1 01 	call	0x342	; 0x342 <LED_ON>
	LED_OFF(LED4_PORT , LED4_PIN);
 3ae:	64 e0       	ldi	r22, 0x04	; 4
 3b0:	83 e0       	ldi	r24, 0x03	; 3
 3b2:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
 3b6:	08 95       	ret

000003b8 <LED_pattern4>:
}

void LED_pattern4(void)
{
	/** LED 1 , LED 2 , LED 3 AND LED 4 ARE ON **/
	LED_ON(LED1_PORT , LED1_PIN);
 3b8:	62 e0       	ldi	r22, 0x02	; 2
 3ba:	82 e0       	ldi	r24, 0x02	; 2
 3bc:	0e 94 a1 01 	call	0x342	; 0x342 <LED_ON>
	LED_ON(LED2_PORT , LED2_PIN);
 3c0:	67 e0       	ldi	r22, 0x07	; 7
 3c2:	82 e0       	ldi	r24, 0x02	; 2
 3c4:	0e 94 a1 01 	call	0x342	; 0x342 <LED_ON>
	LED_ON(LED3_PORT , LED3_PIN);
 3c8:	63 e0       	ldi	r22, 0x03	; 3
 3ca:	83 e0       	ldi	r24, 0x03	; 3
 3cc:	0e 94 a1 01 	call	0x342	; 0x342 <LED_ON>
	LED_ON(LED4_PORT , LED4_PIN);
 3d0:	64 e0       	ldi	r22, 0x04	; 4
 3d2:	83 e0       	ldi	r24, 0x03	; 3
 3d4:	0e 94 a1 01 	call	0x342	; 0x342 <LED_ON>
 3d8:	08 95       	ret

000003da <LED_pattern5>:
}

void LED_pattern5(void)
{
	/** LED 4 IS OFF **/
	LED_OFF(LED1_PORT , LED1_PIN);
 3da:	62 e0       	ldi	r22, 0x02	; 2
 3dc:	82 e0       	ldi	r24, 0x02	; 2
 3de:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
	LED_ON(LED2_PORT , LED2_PIN);
 3e2:	67 e0       	ldi	r22, 0x07	; 7
 3e4:	82 e0       	ldi	r24, 0x02	; 2
 3e6:	0e 94 a1 01 	call	0x342	; 0x342 <LED_ON>
	LED_ON(LED3_PORT , LED3_PIN);
 3ea:	63 e0       	ldi	r22, 0x03	; 3
 3ec:	83 e0       	ldi	r24, 0x03	; 3
 3ee:	0e 94 a1 01 	call	0x342	; 0x342 <LED_ON>
	LED_ON(LED4_PORT , LED4_PIN);
 3f2:	64 e0       	ldi	r22, 0x04	; 4
 3f4:	83 e0       	ldi	r24, 0x03	; 3
 3f6:	0e 94 a1 01 	call	0x342	; 0x342 <LED_ON>
 3fa:	08 95       	ret

000003fc <LED_pattern6>:
}

void LED_pattern6(void)
{
	/** LED 4 AND LED 3 ARE OFF **/
	LED_OFF(LED1_PORT , LED1_PIN);
 3fc:	62 e0       	ldi	r22, 0x02	; 2
 3fe:	82 e0       	ldi	r24, 0x02	; 2
 400:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
	LED_OFF(LED2_PORT , LED2_PIN);
 404:	67 e0       	ldi	r22, 0x07	; 7
 406:	82 e0       	ldi	r24, 0x02	; 2
 408:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
	LED_ON(LED3_PORT , LED3_PIN);
 40c:	63 e0       	ldi	r22, 0x03	; 3
 40e:	83 e0       	ldi	r24, 0x03	; 3
 410:	0e 94 a1 01 	call	0x342	; 0x342 <LED_ON>
	LED_ON(LED4_PORT , LED4_PIN);
 414:	64 e0       	ldi	r22, 0x04	; 4
 416:	83 e0       	ldi	r24, 0x03	; 3
 418:	0e 94 a1 01 	call	0x342	; 0x342 <LED_ON>
 41c:	08 95       	ret

0000041e <LED_pattern7>:
}

void LED_pattern7(void)
{
	/** LED 4 AND LED 3 , LED 2 ARE OFF **/
	LED_OFF(LED1_PORT , LED1_PIN);
 41e:	62 e0       	ldi	r22, 0x02	; 2
 420:	82 e0       	ldi	r24, 0x02	; 2
 422:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
	LED_OFF(LED2_PORT , LED2_PIN);
 426:	67 e0       	ldi	r22, 0x07	; 7
 428:	82 e0       	ldi	r24, 0x02	; 2
 42a:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
	LED_OFF(LED3_PORT , LED3_PIN);
 42e:	63 e0       	ldi	r22, 0x03	; 3
 430:	83 e0       	ldi	r24, 0x03	; 3
 432:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
	LED_ON(LED4_PORT , LED4_PIN);
 436:	64 e0       	ldi	r22, 0x04	; 4
 438:	83 e0       	ldi	r24, 0x03	; 3
 43a:	0e 94 a1 01 	call	0x342	; 0x342 <LED_ON>
 43e:	08 95       	ret

00000440 <LED_pattern8>:
}

void LED_pattern8(void)
{
    /** ALL LEDS ARE OFF **/
	LED_OFF(LED1_PORT , LED1_PIN);
 440:	62 e0       	ldi	r22, 0x02	; 2
 442:	82 e0       	ldi	r24, 0x02	; 2
 444:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
	LED_OFF(LED2_PORT , LED2_PIN);
 448:	67 e0       	ldi	r22, 0x07	; 7
 44a:	82 e0       	ldi	r24, 0x02	; 2
 44c:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
	LED_OFF(LED3_PORT , LED3_PIN);
 450:	63 e0       	ldi	r22, 0x03	; 3
 452:	83 e0       	ldi	r24, 0x03	; 3
 454:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
	LED_OFF(LED4_PORT , LED4_PIN);	
 458:	64 e0       	ldi	r22, 0x04	; 4
 45a:	83 e0       	ldi	r24, 0x03	; 3
 45c:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
 460:	08 95       	ret

00000462 <main>:
int main(void)
{
	/** VARIABLE TO HOLD BUTTON STATUS , COUNTER FOR PRESSING TIMES **/
	static uint8_t button1_status = 0 , button1_counter = 0 ;
	
	Button_init(BUTTON1_PORT , BUTTON1_PIN); /** INITIALIZE BUTTON 1 **/
 462:	64 e0       	ldi	r22, 0x04	; 4
 464:	81 e0       	ldi	r24, 0x01	; 1
 466:	0e 94 3e 00 	call	0x7c	; 0x7c <Button_init>
	
	LED_INIT(LED1_PORT , LED1_PIN); /** INIT LED 1 **/
 46a:	62 e0       	ldi	r22, 0x02	; 2
 46c:	82 e0       	ldi	r24, 0x02	; 2
 46e:	0e 94 9d 01 	call	0x33a	; 0x33a <LED_INIT>
	LED_INIT(LED2_PORT , LED2_PIN); /** INIT LED 2 **/
 472:	67 e0       	ldi	r22, 0x07	; 7
 474:	82 e0       	ldi	r24, 0x02	; 2
 476:	0e 94 9d 01 	call	0x33a	; 0x33a <LED_INIT>
	LED_INIT(LED3_PORT , LED3_PIN); /** INIT LED 3 **/
 47a:	63 e0       	ldi	r22, 0x03	; 3
 47c:	83 e0       	ldi	r24, 0x03	; 3
 47e:	0e 94 9d 01 	call	0x33a	; 0x33a <LED_INIT>
	LED_INIT(LED4_PORT , LED4_PIN); /** INIT LED 4 **/
 482:	64 e0       	ldi	r22, 0x04	; 4
 484:	83 e0       	ldi	r24, 0x03	; 3
 486:	0e 94 9d 01 	call	0x33a	; 0x33a <LED_INIT>
	
	/** ALL lEDS ARE OFF IN THE BEGINNING **/
	LED_OFF(LED1_PORT , LED1_PIN); 
 48a:	62 e0       	ldi	r22, 0x02	; 2
 48c:	82 e0       	ldi	r24, 0x02	; 2
 48e:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
	LED_OFF(LED2_PORT , LED2_PIN);
 492:	67 e0       	ldi	r22, 0x07	; 7
 494:	82 e0       	ldi	r24, 0x02	; 2
 496:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
	LED_OFF(LED3_PORT , LED3_PIN); 
 49a:	63 e0       	ldi	r22, 0x03	; 3
 49c:	83 e0       	ldi	r24, 0x03	; 3
 49e:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
	LED_OFF(LED4_PORT , LED4_PIN);
 4a2:	64 e0       	ldi	r22, 0x04	; 4
 4a4:	83 e0       	ldi	r24, 0x03	; 3
 4a6:	0e 94 a5 01 	call	0x34a	; 0x34a <LED_OFF>
   
    while (1) 
    {
		Is_pressed(BUTTON1_PORT , BUTTON1_PIN , &button1_status);  /* GET THE STATUS OF THE BUTTON */
 4aa:	41 e6       	ldi	r20, 0x61	; 97
 4ac:	50 e0       	ldi	r21, 0x00	; 0
 4ae:	64 e0       	ldi	r22, 0x04	; 4
 4b0:	81 e0       	ldi	r24, 0x01	; 1
 4b2:	0e 94 42 00 	call	0x84	; 0x84 <Is_pressed>

		if (button1_status) /* IF BUTTON IS PRESSED */
 4b6:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <button1_status.1793>
 4ba:	88 23       	and	r24, r24
 4bc:	b1 f3       	breq	.-20     	; 0x4aa <main+0x48>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 4be:	8b e4       	ldi	r24, 0x4B	; 75
 4c0:	9d e1       	ldi	r25, 0x1D	; 29
 4c2:	01 97       	sbiw	r24, 0x01	; 1
 4c4:	f1 f7       	brne	.-4      	; 0x4c2 <main+0x60>
 4c6:	00 c0       	rjmp	.+0      	; 0x4c8 <main+0x66>
 4c8:	00 00       	nop
		{
			_delay_ms(30);  /* DELAY FOR 30 ms TO AVOID BOUNCING */
			 
			Is_pressed(BUTTON1_PORT , BUTTON1_PIN , &button1_status); /* GET THE STATUS OF THE BUTTON AGAIN */
 4ca:	41 e6       	ldi	r20, 0x61	; 97
 4cc:	50 e0       	ldi	r21, 0x00	; 0
 4ce:	64 e0       	ldi	r22, 0x04	; 4
 4d0:	81 e0       	ldi	r24, 0x01	; 1
 4d2:	0e 94 42 00 	call	0x84	; 0x84 <Is_pressed>
			
			if (button1_status) /* IF STATE IS STILL 1 */
 4d6:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <button1_status.1793>
 4da:	88 23       	and	r24, r24
 4dc:	31 f3       	breq	.-52     	; 0x4aa <main+0x48>
			{
				button1_counter++ ; /* UPDATE BUTTON 1 COUNTER */
 4de:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <_edata>
 4e2:	8f 5f       	subi	r24, 0xFF	; 255
 4e4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <_edata>
				
				/** DISPLAY THE PATTERN ACCORDING TO THE NUMBER OF PRESS TIMES (COUNTER) */
				if (button1_counter == 1)
 4e8:	81 30       	cpi	r24, 0x01	; 1
 4ea:	19 f4       	brne	.+6      	; 0x4f2 <main+0x90>
				{
					LED_pattern1();
 4ec:	0e 94 a9 01 	call	0x352	; 0x352 <LED_pattern1>
 4f0:	2b c0       	rjmp	.+86     	; 0x548 <main+0xe6>
				}
				
				else if(button1_counter == 2)
 4f2:	82 30       	cpi	r24, 0x02	; 2
 4f4:	19 f4       	brne	.+6      	; 0x4fc <main+0x9a>
				{
					LED_pattern2();
 4f6:	0e 94 ba 01 	call	0x374	; 0x374 <LED_pattern2>
 4fa:	26 c0       	rjmp	.+76     	; 0x548 <main+0xe6>
				}
				
				else if(button1_counter == 3)
 4fc:	83 30       	cpi	r24, 0x03	; 3
 4fe:	19 f4       	brne	.+6      	; 0x506 <main+0xa4>
				{
					LED_pattern3();
 500:	0e 94 cb 01 	call	0x396	; 0x396 <LED_pattern3>
 504:	21 c0       	rjmp	.+66     	; 0x548 <main+0xe6>
				}
				
				else if(button1_counter == 4)
 506:	84 30       	cpi	r24, 0x04	; 4
 508:	19 f4       	brne	.+6      	; 0x510 <main+0xae>
				{
					LED_pattern4();
 50a:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <LED_pattern4>
 50e:	1c c0       	rjmp	.+56     	; 0x548 <main+0xe6>
				}
				
				else if(button1_counter == 5)
 510:	85 30       	cpi	r24, 0x05	; 5
 512:	19 f4       	brne	.+6      	; 0x51a <main+0xb8>
				{
					LED_pattern5();
 514:	0e 94 ed 01 	call	0x3da	; 0x3da <LED_pattern5>
 518:	17 c0       	rjmp	.+46     	; 0x548 <main+0xe6>
				}
				
				else if(button1_counter == 6)
 51a:	86 30       	cpi	r24, 0x06	; 6
 51c:	19 f4       	brne	.+6      	; 0x524 <main+0xc2>
				{
					LED_pattern6();
 51e:	0e 94 fe 01 	call	0x3fc	; 0x3fc <LED_pattern6>
 522:	12 c0       	rjmp	.+36     	; 0x548 <main+0xe6>
					
				} 
				
				else if(button1_counter == 7)
 524:	87 30       	cpi	r24, 0x07	; 7
 526:	19 f4       	brne	.+6      	; 0x52e <main+0xcc>
				{
					LED_pattern7();
 528:	0e 94 0f 02 	call	0x41e	; 0x41e <LED_pattern7>
 52c:	0d c0       	rjmp	.+26     	; 0x548 <main+0xe6>
					
				}
				
				else if(button1_counter == 8)
 52e:	88 30       	cpi	r24, 0x08	; 8
 530:	59 f4       	brne	.+22     	; 0x548 <main+0xe6>
				{
					LED_pattern8();
 532:	0e 94 20 02 	call	0x440	; 0x440 <LED_pattern8>
					button1_counter = 0 ; /** REINITIALIZE THE COUNTER TO START FROM PATTERN 1 AGAIN */
 536:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <_edata>
 53a:	06 c0       	rjmp	.+12     	; 0x548 <main+0xe6>
				}
			
				while(button1_status)
				{
					Is_pressed(BUTTON1_PORT , BUTTON1_PIN , &button1_status);
 53c:	41 e6       	ldi	r20, 0x61	; 97
 53e:	50 e0       	ldi	r21, 0x00	; 0
 540:	64 e0       	ldi	r22, 0x04	; 4
 542:	81 e0       	ldi	r24, 0x01	; 1
 544:	0e 94 42 00 	call	0x84	; 0x84 <Is_pressed>
				{
					LED_pattern8();
					button1_counter = 0 ; /** REINITIALIZE THE COUNTER TO START FROM PATTERN 1 AGAIN */
				}
			
				while(button1_status)
 548:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <button1_status.1793>
 54c:	81 11       	cpse	r24, r1
 54e:	f6 cf       	rjmp	.-20     	; 0x53c <main+0xda>
 550:	ac cf       	rjmp	.-168    	; 0x4aa <main+0x48>

00000552 <_exit>:
 552:	f8 94       	cli

00000554 <__stop_program>:
 554:	ff cf       	rjmp	.-2      	; 0x554 <__stop_program>
